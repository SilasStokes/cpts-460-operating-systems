Name: Silas Stokes
Email: silas.stokes@wsu.edu
SID: 11655726


===========================================================================
                 CS460 LAB1 Check List

1. Does it boot up the MTX OS?
    A: Yes!

============================================================================

                     CS460 LAB#1 QUESTIONS

    Text edit your answers as a .txt file. Submit it to TA before demo time.

1. On Intel x86 based PCs, during booting, what does BIOS do?
        A:  The BIOS stands for 'basic input/output system'. It's a small program
            used to boot the booter program. In this case it's KC's bs.s file,
            which is loading the a.out generated by t.c into memory at 0x7C00.
             

   How many sectors does BIOS load from the boot device?
        A:  The BIOS loads only one sector (512 bytes). Because now the booter
            is going to move itself to 0x9000 and load the rest of the program.

   Where in memory does BIOS load the booter?
        A:  The booter is runs at address 0x7C00.


2. BIOS loads only 512 bytes of a booter into memory, which is only the 
   beginning part of the booter. How does the booter load the remaining part of 
   the booter into memory?
        A:  The first thing the booter does is move to a safe address, above the
            modifiable memory. Memory 0x9000.

3. Assume a COMPLETE booter is loaded at the segment 0x9000. WHY do we have to
   set the CPU's sgement registers CS,DS,SS,ES to 0x9000?
        A:  Because they will be executing the code there. 

4. How do you find the file /boot/mtx?
        A:  First you get the root inode, which is used to get the DIR * structs 
            where you search for boot. Once you find boot, the DIR * struct has a
            inode_number. You need to use mailmans algorithm to find which block
            and offset to read from to access the inode of boot. Then you repeat
            the process with mtx. 

5. How to load the (disk) blocks of /boot/mtx to the segment 0x1000?__________
        A:  So you set ES to memory 0x1000 by using setes(0x1000), then you read
            the block to offset 0 from the ES (i.e getblk(blk_num, 0). Then ES
            is increased using inces();, which in the assembly code is just moving
            it 0x40 bytes in memory.
